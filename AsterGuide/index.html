<!DOCTYPE html>
<head>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
    var data;
    $(document).ready(function(){
        $.getJSON('aster_functions.json', function(response){
            data = response;
        });
    });
    /*
    names = [];
    for (i=0; i < mydata['children'].length; i++){
        for (j=0; j < mydata['children'][i]['children'].length; j++){
            names.push(mydata['children'][i]['children'][j].name);
        }
    };
    */
   
</script>


<style>

    h4 {
        color:#173E6E;
    }
    h2 {
        color:#173E6E;
    }

    body {
        background-image:url("noisy-texture.png");
    }
    .node {
      cursor: pointer;
    }
    .node circle {
      fill: #FF6E00;
      stroke: #FF6E00;
      stroke-width: 1.5px;
    }
    .node text {
      font: 11px sans-serif;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
    .text_scroll {
        max-height:500px;
        overflow-y:scroll;
    }
</style>

</head>
<body>
    <div class="row">
        <div class="col-md-12">
            <h2 class="text-center"><span style="color:#FF6E00">Teradata Aster</span> Functions Guide</h2>
        </div>
        <div class="col-md-6" id="chart" style="padding-right: 0px;"></div>
        <div class="col-md-6" id="function_text" style="padding-left: 0px;">
            <div id="Attribution" style="display:none">
                <h2 class="text-center">Attribution</h2>
                <h4>Summary</h4>
                <p>
                    The attribution operator is often used in web page analysis. Companies would like to assign weights to pages before certain events, such as a 'click' or a 'buy'. This attribution function enables you to calculate attributions by using a wide range of distribution models.</p>
                <p>
                    There are two different ways to call the attribution SQL-MR function, depending on how many inputs you are using. The multiple input and the single input function calls use very different syntax, so they are documented separately:
                </p>
                <h4>Usage</h4>
                <ul class="nav nav-tabs" role="tablist">
                    <li class="active"><a href="#multiple_attribution" role="tab" data-toggle="tab">Multiple Input</a></li>
                    <li><a href="#single_attribution" role="tab" data-toggle="tab">Single Input</a></li>
                </ul>
                <div class="tab-content">
                    <div class="tab-pane active" id="multiple_attribution">
                        <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
                    </div>
                    <div class="tab-pane" id="single_attribution">
                        <script src="https://gist.github.com/PMeinshausen/f5db870c53700d8217a1.js"></script>
                    </div>
                </div>
            </div>
            <div id="CMAVG" style="display:none">
                <h2 class="text-center">CMAVG</h2>
                <h4>Summary</h4>
                <p>
                    The Cumulative Moving Average (CMAVG) function computes the average of a value from the beginning of a series.
                </p>
                <h4>Background</h4>
                <p>
                    In a cumulative moving average, the data are added to the dataset in an ordered data stream over time. The objective is to compute the average of all the data at each point in time when new data arrived. For example, an investor may want to find the average price of all of the stock transactions for a particular stock over time, up until the current time.
                </p>
                <p>
                    The cumulative moving average computes the arithmetic average of all the rows from the beginning of the series:
                </p>
                <p style="font-family:Latin Modern Mono">
                    new_smavg = sum(a1 ... aN) / N
                </p>
                <p>
                    where N is the number of rows from the beginning of the dataset.
                </p>
                <h4>Usage</h4>
                <script src="https://gist.github.com/PMeinshausen/d7c13e8f7f301a569614.js"></script>
            </div>
            <div id="DTW" style="display:none">
                <h2 class="text-center">DTW</h2>
                <h4>Background</h4>
                <p>
                    Dynamic time warping (DTW) is an algorithm that measures the similarity between two sequences that vary in time or speed.
                </p>
                <p>
                    For example, DTW can detect similarities in walking patterns, even if in one video the person is walking slowly and in another, the same person is walking fast.
                </p>
                <p>
                    DTW has been used to analyze video, audio, and graphics. DTW can be applied to any data that can be represented linearly. One of the applications of DTW is in the field of speech recognition. In this case, DTW can deal with the different speech speeds, which results in better recognition.
                </p>
                <h4>Usage</h4>
                <script src="https://gist.github.com/PMeinshausen/c22f77a7f554ad737ad9.js"></script>
            </div>
            <div id="DWT" style="display:none;">
                <h2 class="text-center">DWT</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    This function implements Mallat’s algorithm which is an iterate algorithm in the Discrete Wavelet Transform (DWT) field, and is designed to apply wavelet transform on multiple sequences simultaneously. The input is typically a set of time series sequences. Each sequence consists of values in a specific order. You specify the wavelet name, transform level, and optionally the extension mode. The result is the transformed sequences in Hilbert space with corresponding component identifier and index. The transformation is also called decomposition.
                </p>
                <p>
                    The result can be filtered to reduce the length of the sequence. And the original sequence can be reconstructed according to the result via IDWT. Thus the function can be adopted in compression and denoise.
                </p>
                <h4>Background</h4>
                <p>
                    DWT is a kind of time-frequency analysis tool for which the wavelets are discretely sampled. DWT is different from the Fourier transform, which provides frequency information on the whole time domain. A key advantage of DWT is that it provides frequency information at different time points.
                </p>
                <p>
                    Mallat’s algorithm can be described as several iterative steps. For example, in the case of a 3- level wavelet transform, the algorithm performs these steps:
                </p>
                <p>
                    <span style="font-weight:bold">1)</span> Use <span style="font-style:italic">S(n)</span> as the original time domain sequence as the input of level 1.<br>
                    <span style="font-weight:bold">2)</span> The input sequence is convolved with high-pass filter <span style="font-style:italic">h(n)</span> and low-pass filter <span style="font-style:italic">g(n)</span>, then the convolved sequences are downsampled respectively.
                    Two sequences are generated. The generated sequences are the detail coefficients <span style="font-style:italic">Dk</span> and the approximation coefficients <span style="font-style:italic">Ak</span> in level <span style="font-style:italic">k</span>.<br>
                    <span style="font-weight:bold">3)</span> If current level <span style="font-style:italic">k</span> reaches max transform level <span style="font-style:italic">n</span>, then go to the end. Otherwise, <span style="font-style:italic">Ak</span> is used as the input sequence for the next level; increase the current level <span style="font-style:italic">k</span> by 1, then go to step 2.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/4a41721519692a9e3ec4.js"></script>
            </div>
            <div id="DWT2D" style="display:none;">
                <h2 class="text-center">DWT2D</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    This function implements wavelet transform on 2 dimensional input, and it is designed to apply wavelet transform on multiple sequences simultaneously. Typically, each sequence is a matrix contains the position in 2 dimensional space and the corresponding values.
                </p>
                <p>
                    Each row in a sequence consists of the sequence identifier (optional), the index of Y axis, the index of X axis, and the corresponding one or more values. Then, you specify the wavelet name, transform level, and optionally the extension mode.
                </p>
                <p>
                    The result is the transformed sequences in Hilbert space with the corresponding component identifier and index. The transformation is also called decomposition as the result is given in multiple components.
                </p>
                <p>
                    A typical use case of DWT2d is:<br>
                    <span style="font-weight:bold">1)</span>Apply DWT2d to the original data and generate the coefficients of matrices and corresponding meta-data.<br>
                    <span style="font-weight:bold">2)</span>Filter the coefficients by various methods (for example, minimum threshold, top n coefficients or just keep the approximate coefficients) according to the object.<br>
                    <span style="font-weight:bold">3)</span>Reconstruct the matrices from the filtered coefficients and compare them with the original ones.<br>
                <h4>Background</h4>
                <p>
                    DWT is a kind of time-frequency analysis tool for which the wavelets are discretely sampled. DWT is different from the Fourier transform, which provides frequency information on the whole time domain. A key advantage of DWT is that it provides frequency information at different time points, which is especially useful to keep local information.
                </p>
                <p>
                    Similar to 1-dimensional DWT, Mallat’s algorithm can be represented as the following iterative steps.                </p>
                <p>
                    <span style="font-weight:bold">1)</span> Use the original time domain sequence (2 dimensional matrix) as the input of level 1.<br>
                    <span style="font-weight:bold">2)</span> In level k, each row of the input matrix is convolved with low-pass filter g(n) and high-pass filter h(n), then each convolved rows are downsampled by column, respectively. Thus, two matrices are generated. After that, each column of the two generated matrices are convolved with the filters g(n) and h(n), and downsampled again. Finally four matrices are given, they are marked as approximation coefficients Ak, horizontal detail coefficients Hk,vertical detail coefficients Vk and diagonal detail coefficients Dk for level n, respectively.<br>
                    <span style="font-weight:bold">3)</span> If current level k reaches max transform level n, then go to the end. Otherwise, Ak is used as the input matrix of next level; increase the current level k by 1, then go to step 2.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/6eaa5447042379f55951.js"></script>
            </div>
            <div id="FrequentPaths" style="display:none">
                <h2 class="text-center">DWT2D</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    FrequentPaths is a function for mining frequent subsequences as patterns in a sequence database. It has broad applications including the analyses of customer purchase behavior, web access patterns, disease treatments, DNA sequences, and so on.
                </p>
                <h4>Background</h4>
                <p>
                    In a sequential pattern mining application, each sequence consists of an ordered list of itemsets, and each itemset contains at least one item. The items are unordered if there are more than one item in one itemset.
                </p>
                <p>
                    If you use a letter in lower case to represent an item, use "()" to enclose items in an itemset and "&lt;&gt;" to enclose itemsets in a sequence, then the sequence "&lt;(a), (b,c), (d)&gt;" is identical to "&lt;(a),(c,b),(d)&gt;" because items in one itemset are unordered, while sequence "&lt;(a),(b,c),(d)&gt;" is different from "&lt;(a),(d),(b,c)&gt;" because the itemsets are ordered. In web click stream analysis, there is only one item in each itemset, and in purchase behavior analysis there might be multiple items in one itemset as a customer might buy more than one item in one shopping session.                
                </p>
                <p>
                    In sequential pattern mining, the conditions for a sequence α to be a subsequence of another sequence β are:
                    <ul>
                        <li>Each itemset ai in α must be a subset of another itemset bj in β.</li>
                        <li>The ai elements in α must have the same order as the bj elements in β.</li>
                    </ul>
                </p>
                <p>
                    A more formal definition is: a sequence α=a1a2...an is called as a subsequence of another sequence β=&lt;b1b2...bm&gt; and β a super sequence of α, if there exists integers 1≤j1&lt;j2&lt;...≤jn≤m such that a1⊆bj1,a2⊆bj2,...,an⊆bjn.
                </p>
                <p>
                    The support of a sequence α in a sequence dataset SDB is defined as the number of sequences in SDB that contain α (that is, they are super sequences of α). 
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/645dab9807b4f9f54146.js"></script>
            </div>
            <div id="IDWT" style="display:none">
                <h2 class="text-center">IDWT</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    IDWT is the inverse function of DWT. IDWT applies inverse wavelet transforms on multiple sequences simultaneously. The inputs are the coefficients of sequences with specified order outputted by DWT and the corresponding wavelet information used in DWT. After running IDWT, the output sequences are the sequences in time domain. Because the output is comparable with the input of DWT, the transformation is also called reconstruction.
                </p>
                <h4>Background</h4>
                <p>
                    These steps describe a typical use case of IDWT:
                </p>
                <ol>
                    <li>Apply DWT to sequences, generate the coefficients of sequences and corresponding meta data.</li>
                    <li>Filter the coefficients by various methods (for example, minimum threshold and top n coefficients) according to the object.</li>
                    <li>Reconstruct the sequences from the filtered coefficients and compare them with the original ones.</li>
                </ol>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/b0e0bdbab4399c948543.js"></script>
            </div>
            <div id="IDWT2D" style="display:none">
                <h2 class="text-center">IDWT2D</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    IDWT2d is the inverse function of DWT2d. Or, more specifically, it applies inverse wavelet transforms on multiple sequences simultaneously. The inputs are the coefficients of sequences with specified order outputted by DWT and the corresponding wavelet information generated during the transformation. After running IDWT2d, the output sequences are the original sequences in matrix forms. As the output is comparable with the input of DWT, the transformation is also called reconstruction.
                </p>
                <h4>Background</h4>
                <p>
                    Similar to IDWT, a typical use case of IDWT2d consists of the following steps:
                </p>
                <ol>
                    <li>Apply DWT2d to the original data, generate the coefficients of matrices and corresponding meta data.</li>
                    <li>Filter the coefficients by various methods (for example, minimum threshold and top n coefficients) according to the object. Thus we may compress the original matrices.</li>
                    <li>Reconstruct the matrices from the filtered coefficients and compare them with the original ones.</li>
                </ol>
                <p>
                    Also, there exists other cases. For example, you may find the flaws in the transformed domain according to the energy of different components and map it back to the original position according to the indexes.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/39a4960a9c5c3b60d1f5.js"></script>
            </div>
            <div id="Path_Analyzer" style="display:none">
                <h2 class="text-center">Path_Analyzer</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The Path_Analyzer function automates path analysis. This function acts as a wrapper function of the following three path functions, which you can use to perform clickstream analysis of common sequences of user pageviews on websites:
                </p>
                <ul>
                    <li>Path_Generator—Generates all the possible paths (sequences of pageviews on a website).</li>
                    <li>Path_Start—Generates all the child paths for a particular parent path and sums up the count of times each child path was traveled by a user.</li>
                    <li>Path_Summarizer—Counts the number of times various paths were traveled and measures the depth in pageviews of each path.</li>
                </ul>
                <p>
                    The Path_Analyzer function is useful for website clickstream analysis of website traffic and other sequence/path analysis tasks such as advertisement or referral attribution.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/bfae79eddf8216b2816d.js"></script>
            </div>
            <div id="Path_Generator" style="display:none">
                <h2 class="text-center">Path_Generator</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    This function takes as input a set of paths where each path is a route (series of pageviews) taken by a user in a single session from the start of the session until its end. For each path, Path Generator generates the correctly formatted sequence and all possible sub-sequences for further analysis by the Path Summarizer function. The first element in the path is the first page a user could visit. The last element of a path is the last page visited by the user.
                </p>
                <p>
                    Together, the Path Generator, Path Summarizer, and Path Starter functions are used to perform clickstream analysis of common sequences of users’ pageviews on a website. The roles of the three functions are:
                </p>
                <ul>
                    <li>Path Generator generates all the possible paths (sequences of pageviews on a website);</li>
                    <li>Path Summarizer counts the number of times various paths were traveled and measures the depth in pageviews of each path; and</li>
                    <li>Path Starter generates all the child paths for a particular parent path and sums up the count of times each child path was traveled.</li>
                </ul>
                <p>
                    In the discussion below, we will use the terms:
                </p>
                <ul>
                    <li>Path: An ordered, start-to-finish series of actions (for example, pageviews) for which you wish to generate sequences and sub-sequences. You will run Path Generator on the set of all observed paths users have traveled while navigating your website.</li>
                    <li>Sequence: The sequence is the path prefixed with a carat ('^') to indicate the start of the path. For example, if a user visited page a, page b, and page c in that order, we would say that his session had the sequence, ^,a,b,c.</li>
                    <li>Sub-sequence: For a given sequence of actions, a sub-sequence is one possible subset of the steps that begins with the initial action. For example, the path a,b,c generates three sub- sequences: ^,a; ^,a,b; and ^,a,b,c.</li>
                </ul>
                <h4>Background</h4>
                <p>
                    This tool is useful for performing clickstream analysis of website traffic. These functions can also be used for doing other types of sequence/path analysis, such as the analysis required for advertisement attribution and referral attribution.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/6c2a3f97f9993d15747d.js"></script>
            </div>
            <div id="Path_Start" style="display:none">
                <h2 class="text-center">Path_Start</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The output of Path Summarizer function is the input to this function. This function generates all the children for a particular parent and sums up their count. Note that the input data has to be partitioned by the parent column.
                </p>
                <h4>Background</h4>
                <p>
                    This function is useful for website clickstream analysis and other sequence/path analysis tasks such as advertisement attribution.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/697ef4725b9a6ef682fc.js"></script>
            </div>
            <div id="Path_Summarizer" style="display:none">
                <h2 class="text-center">Path_Summarizer</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The output of the Path Generator function is the input to this function. This function is used to sum counts on nodes. A node can either be a plain sub-sequence or an exit sub-sequence. An exit sub-sequence is one in which the sequence and the sub-sequence are the same. Exit sub- sequences are denoted by appending a dollar sign ('$') to the end of the sequence.
                </p>
                <h4>Background</h4>
                <p>
                    This function is useful for website clickstream analysis and other sequence/path analysis tasks such as advertisement attribution.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/b94bebb64731887a6473.js"></script>
            </div>
            <div id="SAX" style="display:none">
                <h2 class="text-center">SAX</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    Symbolic Aggregate approXimation (SAX) transforms original time series data into symbolic strings. Once this transformation is complete, the data is more suitable for many additional types of manipulation, both because of its smaller size and the relative ease with which patterns can be identified and compared.                
                </p>
                <h4>Background</h4>
                <p>
                    A time series is a collection of data observations made sequentially in time. Time series occur in virtually every medical, scientific, entertainment and business domain.
                </p>
                <p>
                    Symbolic Aggregate approXimation uses a simple algorithm, with low computational complexity to create symbolic strings from time series data. Using a symbolic representation enables additional functions (for example, Teradata Aster nPath) to easily operate on the data.
                </p>
                <p>
                    The data can also be manipulated using common algorithms such as hashing or regular expression pattern matching. In classic data mining tasks such as classification, clustering, and indexing, SAX is accepted as being as good as some well-known, but storage-intensive methods like Discrete Wavelet Transform (DWT) and Discrete Fourier Transform (DFT).
                </p>
                <p>
                    SAX transforms a time series X of length n into the string of arbitrary length w, where w &lt; n, using an alphabet A of size a &gt; 2.
                </p>
                <p>
                    The SAX algorithm consists of two steps:
                </p>
                <ol>
                    <li>SAX transforms the original time series data into a PAA (Piecewise Aggregate Approximation) representation. This effectively splits the time series data into intervals, and then assigns each interval to one of a limited set of alphabetical symbols (letters) based on the data being examined. The set of symbols used is based on dividing all observed data into “chunks” or thresholds, using the normal distribution curve. Each of these values, or “chunks” is represented by a symbol (a letter). This is a simple way to reduce the dimensionality of the data.</li>
                    <li>The PAA is then converted into a string consisting of letters that represents the patterns occurring in the data over time.</li>
                </ol>
                <p>
                    The symbols created by SAX correspond to the time series features with equal probability, allowing them to be compared and used for further manipulation with reliable accuracy. The time series that are normalized using the zero mean and unit of energy follow the Normal distribution law. By using Gaussian distribution properties, it's easy for SAX to pick equal- sized areas under the Normal curve using lookup tables for the cut lines coordinates, slicing the under-the-Gaussian-curve area. The x coordinates of these lines are called “breakpoints” in the SAX algorithm context.
                </p>
                <h4>Usage</h4>
                </div>
                <ul class="nav nav-tabs" role="tablist">
                    <li class="active"><a href="#partition_function" role="tab" data-toggle="tab">Partition function</a></li>
                    <li><a href="#multiple_input_function" role="tab" data-toggle="tab">Multiple Input</a></li>
                </ul>
                <div class="tab-content">
                    <div class="tab-pane active" id="partition_function">
                        <script src="https://gist.github.com/PMeinshausen/36c1efebda6641de5c16.js"></script>
                    </div>
                    <div class="tab-pane" id="multiple_input_function">
                        <script src="https://gist.github.com/PMeinshausen/b1cd8157575e4337bdf7.js"></script>
                    </div>
                </div>
            </div>
            <div id="Sessionization" style="display:none">
                <h2 class="text-center">Sessionization</h2>
                <div class="text_scroll">
                <h4>Background</h4>
                <p>
                    Sessionization is the process of mapping each click in a clickstream to a unique session identifier. We define a session as a sequence of clicks by a particular user where no more than n seconds pass between successive clicks (that is, if we don’t see a click from a user for n seconds, we start a new session).
                </p>
                <p>
                    Sessionization can be easily done with the Sessionize SQL-MapReduce function. Sample code is included with the Aster SQL-MapReduce Java API. This sessionize SQL-MapReduce function can also be used to detect web crawler (“bot”) activity. If the time between successive clicks is less than the user-specified threshold, bot activity will be flagged.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/4cacd81e23f66a08c208.js"></script>
            </div>
            <div id="nPath" style="display:none">
                <h2 class="text-center">What is Teradata Aster nPath?</h2>
                <div class="text_scroll">
                <p>
                    The Teradata Aster nPath SQL-MR function allows you to perform regular pattern matching over a sequence of rows from one or more inputs. For clarity, this document refers to each sequence of matched rows as a matched pattern.                
                </p>
                <p>
                    With Teradata Aster nPath, you can find sequences of rows that match a pattern of your choice. The Teradata Aster nPath function lets you use symbols when building patterns. Symbols let you define the pattern matching conditions and help you extract information from these matched rows.
                </p>
                <p>
                    The Teradata Aster nPath function lets you:
                </p>
                <ol>
                    <li>use a regular expression to specify a pattern you want to match in an ordered collection of rows and label individual matching rows with symbols; and</li>
                    <li>compute SQL aggregates on or find particular values in each matched pattern (Teradata Aster nPath uses the symbols you define for matching rows to get these aggregates and values).</li>
                <ol>
                <p>
                    The Teradata Aster nPath function uses regular expressions because they are simple, widely understood, and flexible enough to express most search criteria. While most uses of regular expressions focus on matching patterns in strings of text; Teradata Aster nPath enables matching patterns in sequences of rows.
                </p>
                <p>
                    The Teradata Aster nPath function performs fast analysis on ordered data. The clauses in Teradata Aster nPath let you express complicated pathing queries and ordering relationships that might otherwise require you to write multi-level joins of relations in SQL. With Teradata Aster nPath, you indicate a desired ordering and then specify a pattern that is matched across the ordered rows of data.
                </p>
                <p>
                    For each matched pattern in the sequence of rows, Teradata Aster nPath generates a row of output that contains SQL aggregates computed over the rows in the matched pattern.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/b35dea788fbcaa25c756.js"></script>
            </div>
            <div id="Approximate Distinct Count" style="display:none">
                <h2 class="text-center">Approximate Distinct Count</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    Based on probabilistic counting algorithms, this function quickly estimates the number of distinct values in a column or combination of columns, while scanning the table only once.
                </p>
                <p>
                    For a column or column combination with large cardinality, it can calculate an approximate count of the distinct values in much less time than would be required to calculate a precise distinct count using SQL’s DISTINCT.
                </p>
                <h4>Background</h4>
                <p>
                    For more information about Probabilistic Counting Algorithms, see Probabilistic Counting Algorithms for Data Base Applications, by Philippe Flajolet and G. Nigel Martin (http://portal.acm.org/citation.cfm?id=5215).
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/f88634b0833ff41051e7.js"></script>
            </div>
            <div id="Approximate Percentile" style="display:none">
                <h2 class="text-center">Approximate Percentile</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    This function computes approximate percentiles for one or more columns of data. The accuracy of the approximation is a parameter the user can vary. Higher accuracy requires longer compute time and vice versa. Optionally, you can specify a column to group by, to compute approximate percentiles over different groups.
                </p>
                <h4>Background</h4>
                <p>
                    The function is based on an algorithm developed by Greenwald and Khanna. It gives e- approximate quantile summaries of a set of N elements, where e is the value you specify as the function’s ERROR parameter. Given any rank r, an e-approximate summary returns a value whose rank r' is guaranteed to be within the interval [r - eN, r + eN]. The algorithm has a worst case space requirement of O((1/e) * log(eN)).
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/24e5a689047d60973370.js"></script>
            </div>
            <div id="ConfusionMatrix" style="display:none">
                <h2 class="text-center">ConfusionMatrix</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    In the field of artificial intelligence, a confusion matrix is a specific table layout that allows visualization of the performance of an algorithm, typically a supervised learning one (in unsupervised learning it is usually called a matching matrix).
                </p>
                <p>
                    Each column of the matrix represents the instances in a predicted class, while each row represents the instances in an actual class.
                </p>
                <p>
                    The name stems from the fact that it makes it easy to see if the system is confusing two classes (that is, commonly mislabeling one as another). Outside artificial intelligence, the confusion matrix is often called the contingency table or the error matrix.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/9bba8d071aa79ee4aec3.js"></script>
            </div>
            <div id="Correlation" style="display:none">
                <h2 class="text-center">Correlation</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The correlation functions, Corr_Reduce and Corr_Map, compute a global correlation between any pair of columns (COLUMNPAIRS) from a table. You may run this pair of functions on multiple pairs of columns in a single invocation. Measuring correlation allows you to determine if the value of one variable is useful in predicting the value of another.
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/f70803be05ca96251f4d.js"></script>
            </div>
            <div id="Distribution Matching" style="display:none">
                <h2 class="text-center">Distribution Matching</h2>
                <div class="text_scroll">
                <p>
                    The distribution matching function distnmatch carries out hypothesis testing and finds the best matching distribution for the data
                </p>
                <h4>Summary</h4>
                <p>
                    The distnmatch function tests the hypothesis that the sample data comes from the specified reference distribution. In this mode, this function carries out up to four tests simultaneously:
                </p>
                <ul>
                    <li>Anderson-Darling test</li>
                    <li>Kolmogorov-Smirnov test</li>
                    <li>Cramer-von Mises criterion</li>
                    <li>Pearson's Chi-squared test</li>
                </ul>
                <h4>Usage</h4>
                </div>
            </div>
            <div id="EMAVG" style="display:none">
                <h2 class="text-center">EMAVG</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The exponential moving average function, EMAVG, computes the average over a number of points in a time series but applies a damping (weighting) factor to older values. The weighting for the older values decreases exponentially without entirely discarding the older values.
                </p>
                <h4>Background</h4>
                <p>
                    Exponential moving average (EMA), sometimes also called an exponentially weighted moving average (EWMA), applies weighting factors that decrease exponentially. The weighting for each older data point decreases exponentially, giving much more importance to recent observations while still not discarding older observations entirely.
                </p>
                <p>
                    We compute the arithmetic average of the first n rows as specified by START_ROWS argument. Then, for each subsequent row, we compute the new value as:
                </p>
                <p style="font-family:Latin Modern Mono">
                    new_emavg = alpha * new_value + (1-alpha) * old_emavg
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/feffd707471e071bd1df.js"></script>
            </div>
            <div id="Enhanced Histogram Function" style="display:none">
                <h2 class="text-center">Enhanced Histogram Function</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The enhanced histogram function (represented by Hist_Map and Hist_Reduce) adds these new capabilities over the existing histogram function (represented by histogram_map and histogram_reduce):
                </p>
                <ul>
                    <li>Bin selection—The new function is equipped with algorithms that determine the number of equi-spaced bins without your intervention.</li>
                    <li>Non-integer bin ranges—The new function supports non-integer bin ranges.</li>
                    <li>Bin IDs and bin ranges in the output columns—By default, the output columns include bin IDs, bin ranges, and bin percentages.</li>
                    <li>Bin ranges—The new function supports left-inclusive and right-inclusive bin ranges in the new function.</li>
                    <li>Bin breaks—The bin breaks generated by the function are always aligned to multiples of a power of ten or multiples of five times a power of ten.</li>
                    <li>Multiple histograms—You can build separate histograms for distinct groups by values.</li>
                </ul>
                </div>
            </div>
            <div id="FMeasure" style="display:none">
                <h2 class="text-center">FMeasure</h2>
                <div class="text_scroll">
                <h4>Summary</h4>
                <p>
                    The FMeasure function calculates the accuracy of a test (usually the output of a classifier).
                </p>
                <h4>Background</h4>
                <p>
                    In statistics, the F1 score (also F-score or F-measure) is a measure of a test’s accuracy. It considers both the precision p and the recall r of the test to compute the score:
                </p>
                <ul>
                    <li>p is the number of correct results divided by the number of all returned results.</li>
                    <li>r is the number of correct results divided by the number of results that should have been returned.</li>
                </ul>
                <p>
                    The F1 score can be interpreted as a weighted average of the precision and recall, where an F1 score reaches its best value at 1 and its worst score at 0.
                </p>
                <p>
                    The traditional F-measure or balanced F-score (F1 score) is the harmonic mean of precision and recall:
                </p>
                <p>
                    F =2*precision*recall / (precision+recall)</br>
                    The general formula for a positive real β is:</br>
                    Fβ =(1+β*β)*precision*recall /(β*β*precision+recall)
                </p>
                <h4>Usage</h4>
                </div>
                <script src="https://gist.github.com/PMeinshausen/84d802a638bc4261c221.js"></script>
            </div>
            <div id="GLM" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="GLMPredict" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Histogram" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="KNN" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="LARS Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="LinReg" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Percentile" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Principal Component Analysis" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Sample" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="SMAVG" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Support Vector Machines" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="VWAP" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="WMAVG" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="LDA Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Levenshtein Distance" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Naive Bayes Text Classifier" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Named Entity Recognition" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="nGram" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="PoSTagger" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Sentenizer" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Sentiment Extraction Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="TF_IDF" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Text_Classifier" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Text_Parser" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="TextChunker" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="TextMorph" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="TextTagging" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="TextTokenizer" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Canopy" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="KMeans" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="KMeansPlot" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Minhash" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Naive Bayes Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Random Forest Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Single Decision Tree Functions" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Basket_Generator" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="CFilter" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="WSRecommender" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="AllPairsShortestPath" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Betweenness" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Closeness" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="EigenvectorCentrality" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="LocalClusteringCoefficient" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="LoopyBeliefPropagation" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="nTree" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="PageRank" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Antiselect" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Apache Log Parser" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="IdentityMatch" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="IpGeo" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="JSONParser" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Multicase" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="MurmurHash" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="OutlierFilter" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="PSTParserAFS" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Pack" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Pivot" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Unpack" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="Unpivot" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="XMLParser" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="XMLRelation" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="CfilterViz" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
            <div id="NpathViz" style="display:none">
                <script src="https://gist.github.com/PMeinshausen/ffeac15ed5f289a8d387.js"></script>
            </div>
        </div>
    </div>

<script>

    var names_list = ["Attribution", "CMAVG", "DTW", "DWT", "DWT2D", "FrequentPaths", "IDWT", "IDWT2D", "Path_Analyzer", "Path_Generator", "Path_Start", "Path_Summarizer", "SAX", "Sessionization", "nPath", "Approximate Distinct Count", "Approximate Percentile", "ConfusionMatrix", "Correlation", "Distribution Matching", "EMAVG", "Enhanced Histogram Function", "FMeasure", "GLM", "GLMPredict", "Histogram", "KNN", "LARS Functions", "LinReg", "Percentile", "Principal Component Analysis", "Sample", "SMAVG", "Support Vector Machines", "VWAP", "WMAVG", "LDA Functions", "Levenshtein Distance", "Naive Bayes Text Classifier", "Named Entity Recognition", "nGram", "PoSTagger", "Sentenizer", "Sentiment Extraction Functions", "TF_IDF", "Text_Classifier", "Text_Parser", "TextChunker", "TextMorph", "TextTagging", "TextTokenizer", "Canopy", "KMeans", "KMeansPlot", "Minhash", "Naive Bayes Functions", "Random Forest Functions", "Single Decision Tree Functions", "Basket_Generator", "CFilter", "WSRecommender", "AllPairsShortestPath", "Betweenness", "Closeness", "EigenvectorCentrality", "LocalClusteringCoefficient", "LoopyBeliefPropagation", "nTree", "PageRank", "Antiselect", "Apache Log Parser", "IdentityMatch", "IpGeo", "JSONParser", "Multicase", "MurmurHash", "OutlierFilter", "PSTParserAFS", "Pack", "Pivot", "Unpack", "Unpivot", "XMLParser", "XMLRelation", "CfilterViz", "NpathViz"]    

    var margin = {top: 20, right: 80, bottom: 20, left: 120},
        width = 680 - margin.right - margin.left,
        height = 900 - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root;

    var tree = d3.layout.tree()
        .size([height, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("div#chart").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    /*
    d3.json("aster_functions.json", function(error, flare){
        thisroot = flare;

        new_root = JSON.parse(JSON.stringify(thisroot));

      names = [];
      for (i=0; i < new_root['children'].length; i++){
          for (j=0; j < new_root['children'][i]['children'].length; j++){
              names.push(new_root['children'][i]['children'][j].name);
          }
      };
      names_list = JSON.parse(JSON.stringify(names));
      console.log(names_list);
    })
    */

    d3.json("aster_functions.json", function(error, flare) {
      root = flare;
      root.x0 = height / 2;
      root.y0 = 0;

      function collapse(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }
      }

      root.children.forEach(collapse);
      update(root);
    });

    d3.select(self.frameElement).style("height", "900px");

    function update(source) {

      var nodes = tree.nodes(root).reverse(),
          links = tree.links(nodes);

      nodes.forEach(function(d) { d.y = d.depth * 180; });

      var node = svg.selectAll("g.node")
          .data(nodes, function(d) { return d.id || (d.id = ++i); });

      var nodeEnter = node.enter().append("g")
          .attr("class", "node")
          .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; });

      nodeEnter.append("circle")
          .attr("r", 1e-6)
          .style("fill", function(d) { return d._children ? "orange" : "#FF6E00"; })
          .on("click", function(d){ click(d); update(d); });

      nodeEnter.append("text")
          .attr('class', 'node_text')
          .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
          .attr("dy", ".35em")
          .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
          .text(function(d) { return d.name; })
          .style("fill-opacity", 1e-6)
          .on('mouseover', function(){
            d3.select(this).style({'text-decoration': 'underline'});
          })
          .on('mouseout', function(){
            d3.select(this).style({'text-decoration': 'none'});
          })
          .on('click', function(d){ 
            if ($.inArray(d.name, names_list) > -1){
                update_info(d);
                }
          });

      /*
      d3.selectAll('.node_text')
          .on('click', function(d){
            console.log("this");
            update_info(d);
      });
      */

    

      var nodeUpdate = node.transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

      nodeUpdate.select("circle")
          .attr("r", 6.0)
          .style("fill", function(d) { return d._children ? "orange" : "#FF6E00"; });

      nodeUpdate.select("text")
          .style("fill-opacity", 1);

      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
          .remove();

      nodeExit.select("circle")
          .attr("r", 1e-6);

      nodeExit.select("text")
          .style("fill-opacity", 1e-6);

      var link = svg.selectAll("path.link")
          .data(links, function(d) { return d.target.id; });

      link.enter().insert("path", "g")
          .attr("class", "link")
          .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal({source: o, target: o});
          });

      link.transition()
          .duration(duration)
          .attr("d", diagonal);

      link.exit().transition()
          .duration(duration)
          .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
            return diagonal({source: o, target: o});
          })
          .remove();

      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }


    function click(d) {

      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      //update(d);
      //update_info(d);
    };

    function update_info(d){
        
        for (i=0; i<names_list.length; i++){
            var the_id = names_list[i];
            console.log(the_id);
            console.log(document.getElementById(the_id).style.display);
            if (document.getElementById(the_id).style.display === "none"){
                $(document.getElementById(the_id)).hide();
            }
        };

        
        $(document.getElementById(d.name)).show();
        //$("div[id ="+d.name+"]").show();

    };

</script>



</body>
